Base系列编码	编码只是让字符串数据更友好的展示输出
Base64:使用了64个可打印的字符(A-Z,a-z,0-9,+,/)
Base16:使用了16个可打印字符(A-F,0-9)
Base16:结尾没有等号,数字多于字母
Base32:字母多余数字,明文数量超过十个,结尾可能会有很多的符号
Base64:一般情况下结尾会有一个或者多个等号,明文很少的时候可能没有
Base100:密文由Emoji表情组成

MD5		加密不可逆      MD5和sha系类均属于加盐值类加密不可逆       MD5算法中的默认加密中的伪key 0123456789abcdef
实质是一种消息摘要算法,一个数据的MD5值是为一的
MD5的主要特征:
密文一般采用16位或者32位其中16位取的是32位的9-25位的值      以及40位的HMAC加密
组成方式为字母(a-f)和数字(0-9)混合显示字母可以全是大写或者小写


SHA系列
SHA指的是SHA算法家族SHA-1,SHA-2,SHA-3
其中SHA-2是SHA-224,SHA-256,SHA-384,SHA-512的并称
SHA-3是SHA3-224,SHA3-256,SHA3-384,SHAKE128,SHAKE256的并称
SHA-1:字母(a-f)和数字(0-9)混合,固定位数40位
SHA-224,SHA3-224:字母(a-f)和数字(0-9)混合固定位数56位
SHA-256,SHA3-256:字母(a-f)和数字(0-9)混合,固定位数64位
SHA-384/SHA3-384:字母(a-f)和数字(0-9)混合,固定位数96位
SHA-512/SHA3-512:字母(a-f)和数字(0-9)混合,固定位数128位


对称加密AES DES 3DES 

非对称加密RSA   其中包含公钥和私钥,但是在一般用户使用的过程只能找到公钥文件,私钥文件存储在服务器
16进制数据加密大概率是对称加密以及非对称加密


在一般的搜索获取的过程中将axios(在实际的寻找过程中可以将async.js文件中的进行查找),vue,min,react,jquery的先忽略

一般方法搜索关键字:打开全局搜索(定位位置比较准确但是搜索到的位置比较多需要进行筛选,容易搜索不到)


第二种方法:使用Element元素的事件列表获取相对应的事件,将对应的事件删除后重新进行操作
判断是否可以继续操作如果可以那么就不是要查找的Dom事件,在确定事件后查看对应js代码
在对应的js文件中对对应关键字下断点进行调试,逐个进入未知的js文件下断点找关键字,
直到找到算法,可以在控制台拷贝相应代码进行调试,在调试的时候想要看某个值,需要让断点的位置定位当前值的行,否则看到的数据可能是虚假的值
但是 Dom事件定位比较靠前也容易搜索不到,并且这种方法不需要分析堆栈的走向

第三种方法XHR断点
好处:定位位置在发包函数,可以进行跟栈
坏处:只能用于XHR的数据包
如何寻找:在请求的过程中抓取数据观察Initiator如果显示的是一个js文件(.js放在上面会有堆栈的提示),那么可以使用XHR断点,否则不能断点
如何使用:复制找到的数据包的请求的url地址使用问号前的,问号后的数据是参数,选取问号前的除了域名意外的"/login/login3",在点击source资源也就是源代码那个菜单中,选择右侧的XHR点击+号或鼠标右键添加
xhr breakpoint 进行过滤,支持正则
通过network抓包抓取数据观察Initiator如果显示的是一个js文件,点击提示的js中的函数下断点,排除堆栈命名为jquery的

如果不是XHR是other,document则搜索问号前的在element元素界面中函数进行赋值,之后在全局搜索该函数下断,在跟栈过程中copy运行报错,缺啥补啥,先在局部js文件中查找,后进行全局搜索

如何使用fd本地联调,抓包将需要的js代码文件在浏览器右键打开,确认抓取到js数据,在fd的autoresponse,指的是自动本地替换,,将抓取到的js代码放入autoresponse,将格式化好的需要替换的js保存在本地目录,下拉框选择find a file,选择到js文件,勾选上方放的三个单选框,不勾选下方离下拉选框最近的单选框(Match only once),再次刷新浏览器观察转包是否替换成功,如果未替换成功需要正则https://xxx.com/to8torsaszb.js?=\d+其中\d是数字,+是匹配1-多个,*贪婪匹配0个或多个,将下拉选框上面的设置为正则匹配regex,之后可以进行本地调试debugger;
xxxx未定义:定义为var xxx={};或者var xxx=this;

define()定义的MD5之类可以将最外层define删除,在内部的module.exports=xxx换为yyy=xxx;在加一个全局变量var yyy;

!(function(){
})()


js中用:表示的一般是对象 例如:MD5: function(){}
在扣去对象的代码时需要扣全,也就是寻找离他最近的括号也就是MD5:在什么对象内,再将对象完整扣下后可以将函数进行调用,使用对象.方法()
或者在扣代码时,将MD5 整个扣下后将函数进行改写,改为var xxx=function(){}   //function xxx(){}
在扣代码时,对代码进行改写的越少越好
如果需要改写的函数不是在你需要调试的对象中,可以将他使用对象.xxx=yyy 的方式进行赋值,在赋值成功过后使用对象进行调用导出时可以使用window.xxx=yyy进行调用   

常见代码混淆eval,jsfuck,aa混淆,oo混淆
js默认支持unicode
混淆常量名称,混淆逻辑,混淆代码执行顺序
eval 具有执行js代码的功能,使用浏览器的v8引擎可以将函数等在eval()内执行使用atob是bs4解密使用btoa是bs4加密
eval进行的浏览器加密可以使用下断点的方式解决,在断点运行到指定位置时
oo混淆也是直接在最后一行下断点,可以查看值,aa,jj加密也是一样将return中的值在控制台输出调试
js中'.'无法混淆,':'一般是定义对象,$一个指的是Function函数,将括号与括号对应起来,就可以通过下断点浏览器调试的方式取得未被加密的值
使用eval=function(){debugger;},Function=function(){debugger;}的方式下断点,通过arguments的方式在控制台查看传入的参数,或者在自定义的函数下断点
在遇到多个\\,或者//可能是转义字符,需要将两个删去一个才能在浏览器环境中得到结果
eval和Function都可以进行二次赋值或者改变函数,使得函数可以被hook

浏览器实现的自己实现的一些类location navigator      openssl中的加密方法btoa aes des md5均可以直接在浏览器环境中调试
DOM BOM最终都是js对象,所有js引擎都有一个功能,功能是可以给js添加任意对象,删除任意对象,并且关联本地代码
浏览器实现的对象默认添加只读属性

如何伪造浏览器环境:
1.要伪造什么        全部伪造    jsdom在python环境   nodejs
                   给指定的网站伪造
    如何知道网站检测什么:1.通过调试,2.全局异常捕获3.通过本地环境运行查看报错
    
2.如何伪造
    例如:伪造navigator
    var navigator={
        useragent:""
    }


反调试:显性例如网站debugger检测f12,检测是否在调试进入死循环
        隐形检测:暗桩(错误逻辑)

如果函数xx被调用,可以使用xx.caller查看当前方法的上一级是哪里调用的

虚拟机指的是使用eval或者Function函数,在进入调试时会显示VM字样在部分字段中
        回退上一个堆栈观察,将函数设置为空function(){},或者是找到调用函数的位置比如说是定时器运行,将定时器设置为空函数,或者是改变Function 函数的原型链  Function.prototype.constructor=function(){} Function.prototype.constructor=function(x){if(x==debugger)}
非虚拟机:非虚拟机可以鼠标右键,使用contine to here, 或者右键断点位置编辑段的间的状态编辑条件断点设置为false,或者解开所有断点在浏览器的堆栈上面
        直接替换代码,使用浏览器自带的重写功能,也就是edge的覆盖  但是会添加动态的js,只能通过hook的方式  或者通过油猴插件

open作为系统的发包函数,当发现所需要的参数已经加密过,向上找栈,找到一个还没有加密的参数位置,之后下断点调试
then可能含有加密,需要下断点调试,在call之前下断点调试

使用ctrl shift和+实现代码的缩进,在idea中